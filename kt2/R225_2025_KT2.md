# KT2 — Dekompozicija Ordering i Shipping & Logistics podsistema

###### Danilo Cvijetić R225/2025

---

## 1. Pregled sistema

Ordering sistem predstavlja podsistem Temu marketplace platforme koji je zadužen za kreiranje i upravljanje porudžbinama, kontrolu životnog ciklusa porudžbine i orkestraciju procesa plaćanja (Payment system) i isporuke (Shipping & Logistics system). Sistem mora da garantuje konzistentnost poslovnog toka između kupca, payment sistema i shipping sistema.

Shipping & Logistics sistem je eksterni podsistem odgovoran za fizičku isporuku porudžbina, praćenje pošiljki i upravljanje statusima isporuke. Sa Ordering sistemom komunicira asinhrono putem Kafka događaja i webhook mehanizama, čime se izbjegava čvrsta sprega između sistema.

Oba podsistema su projektovana kao mikroservisi bazirani na event-driven arhitekturi. Oni su stateless što znači da se sva stanja čuvaju se u bazi podataka. Takođe mogu skalirati horizontalno nezavisno od ostalih podsistema.

### Tehnologije

| Komponenta | Tehnologija | Namjena u sistemu |
|---|---|---|
| Backend aplikacija | Go (net/http + chi) | HTTP server, poslovna logika, state machine |
| Baza podataka | Apache Cassandra | Perzistencija porudžbina, stavki, statusa, pošiljki |
| Keš / pomoćni sloj | Redis | Checkout cache, distributed locking, deduplication, rate limiting |
| Message broker | Apache Kafka | Asinhrona komunikacija sa Payment i Shipping servisima |

---

## 2. DFD (Data Flow Diagrams)

### DFD Level 0 — Ordering System

![DFD Level 0](./kt2dfd0.png)

### DFD Level 1 — Ordering System (Ordering + Shipping)

![DFD Level 1](./kt2dfd1.png)

### Opis tokova podataka (DFD Level 1)

U nastavku je eksplicitan opis svakog procesnog čvora sa DFD Level 1 dijagrama: koji podaci ulaze, koji izlaze, i kojim protokolom se prenose.

#### P1 — Order Management

Centralni čvor koji prima korisničke zahtjeve i koordinira ostale procesne čvorove.

- **Ulaz od Customer-a**: `Create Order / Checkout` zahtjev (REST/JSON over HTTPS) koji sadrži `cart_id`, `shipping_address`, `payment_method_ref` i listu `cart_items` sa `product_id` i `quantity` za svaki artikal.
- **Izlaz ka Customer-u**: `Order Confirmation` (REST/JSON) sa `order_id`, `status`, `estimated_total`, `created_at`. U slučaju greške vraća strukturirani `Order Status / Errors` odgovor.
- **Izlaz ka P2 (Catalog & Price Snapshot)**: lista `product_ids` i `quantities` iz korpe za koje treba preuzeti trenutne cijene. Komunikacija je sinhrona (interni poziv unutar servisa).
- **Ulaz od P2**: immutable snapshot podataka (`product_name`, `sku`, `unit_price`, `currency`, `snapshot_timestamp`) za svaki artikal.
- **Izlaz ka P3 (Payment Orchestration)**: `Order ID` i `Total Amount` — šalju se kao Kafka event `PaymentRequested` na topic `payment.requests`.
- **Ulaz od P3**: `Payment Status` kao Kafka event (`PaymentSucceeded` ili `PaymentFailed`) sa topic-a `payment.results`.
- **Izlaz ka P4 (Shipping Orchestration)**: nakon potvrđenog plaćanja, šalje `Paid Order` sa `order_id`, `shipping_address`, `items[]` kao Kafka event `ShippingInitiated` na topic `shipping.requests`.
- **Izlaz ka P5 (Order Persistence)**: `Persist Order` — naredba za čuvanje order podataka (header + stavke + inicijalni status) u Cassandra bazu.

#### P2 — Catalog & Price Snapshot

Preuzima aktuelne podatke o proizvodima iz Catalog Service-a i kreira immutable snapshot cijena u trenutku checkout-a, čime se garantuje da se cijena ne može promijeniti nakon što je kupac potvrdio narudžbinu.

- **Izlaz ka Catalog Service**: `Fetch Product & Price` zahtjev (REST/JSON over HTTPS ili gRPC) sa listom `product_ids`.
- **Ulaz od Catalog Service**: `Product Data` — aktuelne cijene, nazivi, SKU, dostupnost.
- **Izlaz ka D2 (Order Item Snapshots)**: `Immutable Snapshot` (Price, Name, SKU, Timestamp) — CQL INSERT u Cassandra tabelu `order_item_snapshots` sa `order_id` kao partition key. Zapis je write-once i ne mijenja se nakon kreiranja.
- **Izlaz ka P1**: snapshot podaci proslijeđeni nazad radi obračuna ukupne cijene.

#### P3 — Payment Orchestration

Upravlja komunikacijom sa eksternim Payment servisom. Ne procesuira plaćanja direktno, već orkestrira tok: šalje zahtjev za autorizaciju i čeka rezultat.

- **Izlaz ka Payment Service**: `Authorize / Capture` — Kafka event `PaymentRequested` sa `order_id`, `amount`, `currency`, `payment_method_ref` na topic `payment.requests`.
- **Ulaz od Payment Service**: `Payment Result` — Kafka event sa `order_id`, `payment_intent_id`, `status` (succeeded/failed), `failure_reason` sa topic-a `payment.results`.
- **Izlaz ka P1**: proslijeđen `Payment Status` za dalju orkestraciju.

#### P4 — Shipping Orchestration

Upravlja komunikacijom sa Shipping & Logistics servisom. Kreira zahtjeve za pošiljku i prima ažuriranja statusa.

- **Izlaz ka Shipping & Logistics Service**: `Create Shipment` — Kafka event `ShippingInitiated` sa `order_id`, `shipping_address`, `items[]`, `weight_estimate` na topic `shipping.requests`.
- **Ulaz od Shipping & Logistics Service**: `Shipment ID, Tracking Info` — Kafka event ili webhook callback sa `shipment_id`, `tracking_number`, `carrier`, `estimated_delivery`. Webhook dolazi kao HTTP POST na dedicirani endpoint `/webhooks/shipping` sa HMAC potpisom.
- **Ulaz od Shipping & Logistics Service (webhook)**: `Delivery Status Update` — webhook pozivi sa statusnim događajima (`ShipmentCreated`, `ShipmentDispatched`, `ShipmentInTransit`, `ShipmentDelivered`, `ShipmentFailed`). Svaki sadrži `shipment_id`, `status`, `timestamp`, `metadata`.
- **Izlaz ka D3 (Order Status History)**: `Order State Changes` — CQL INSERT u tabelu `order_status_history` za svaku promjenu stanja.
- **Izlaz ka D4 (Shipment Data)**: `Shipment Record` — CQL INSERT/UPDATE u tabelu `shipments` sa tracking informacijama.
- **Izlaz ka P5**: `Status Event` — notifikacija o promjeni stanja porudžbine radi ažuriranja glavnog order zapisa.

#### P5 — Order Persistence

Odgovoran za atomičko čuvanje order podataka (header + stavke) u bazu i slanje notifikacija.

- **Ulaz od P1**: kompletan order agregat za perzistenciju.
- **Izlaz ka D1 (Orders — Cassandra)**: `Order Aggregate` — CQL batch write koji upisuje order header i sve stavke u istu particiju.
- **Izlaz ka Notification Service**: `Order / Shipment Notifications` — Kafka event na topic `notifications` sa `order_id`, `customer_id`, `event_type`, `details` radi slanja email/push obavještenja kupcu.

#### Skladišta podataka

| Oznaka | Naziv | Sadržaj | Tehnologija |
|---|---|---|---|
| D1 | Orders | Order header (`order_id`, `customer_id`, `total`, `status`, `created_at`) i stavke (`item_id`, `product_id`, `quantity`, `unit_price`) | Cassandra |
| D2 | Order Item Snapshots | Immutable snapshot cijena i naziva proizvoda u trenutku checkout-a (`order_id`, `product_id`, `price`, `name`, `sku`, `snapshot_time`) | Cassandra |
| D3 | Order Status History | Hronološki log svih promjena stanja (`order_id`, `status`, `changed_at`, `reason`, `actor`) | Cassandra |
| D4 | Shipment Data | Podaci o pošiljkama (`shipment_id`, `order_id`, `tracking_number`, `carrier`, `status`, `updated_at`) | Cassandra |

---

## 3. Dekompozicija Go platforme

Go (Golang) je statički tipiziran, kompajliran programski jezik razvijen u Google-u. U Ordering sistemu koristi se kao osnova za backend aplikaciju. U nastavku je detaljno razlaganje Go platforme na sastavne komponente relevantne za ovaj sistem.

### 3.1 Go kompajler i build sistem

Go kompajler (`go build`) transformiše izvorni kod u statički linkovane binarne fajlove. Proces kompilacije prolazi kroz nekoliko faza:

1. **Parser** — izvorni kod se tokenizuje i parsira u AST. Go ima namjerno jednostavnu gramatiku bez dvosmislenosti, što omogućava veoma brzo parsiranje.
2. **Type checking** — AST se analizira za tipsku ispravnost. Go-ov tipski sistem je strukturalan (structural typing za interfejse), što znači da tip zadovoljava interfejs ako implementira sve metode, bez eksplicitne deklaracije (`implements` ne postoji).
3. **SSA (Static Single Assignment) generisanje** — tipski provjeren AST se prevodi u SSA međureprezentaciju na kojoj se izvršavaju optimizacione faze: dead code elimination, bounds check elimination, inlining, escape analysis (određuje da li varijabla može ostati na stack-u ili mora na heap).
4. **Machine code generisanje** — SSA se prevodi u mašinski kod za ciljnu platformu. Go ima sopstveni backend (ne koristi LLVM), što mu daje veoma kratka vremena kompilacije. Rezultat je statički linkovan binarni fajl bez eksternih runtime zavisnosti.

`go mod` je sistem za upravljanje zavisnostima. Projekat definiše zavisnosti u `go.mod` fajlu sa semantičkim verzionisanjem, dok `go.sum` sadrži kriptografske hash-eve svake zavisnosti radi verifikacije integriteta. Go Checksum Database (`sum.golang.org`) pruža javni, append-only log hash-eva svih poznatih modula, čime se sprečava podmjena zavisnosti (supply chain attack).

`go vet` je statički analizator koji detektuje česte greške koje kompajler ne prijavljuje. Na primjer: formatne stringove čiji argumenti ne odgovaraju tipu, neiskorišćene rezultate poziva, ili kopiranje lock-ova.

### 3.2 Go Runtime

Go runtime je biblioteka koja se linkuje u svaki Go binarni fajl i pruža servise neophodne za izvršavanje programa. Za razliku od JVM ili CLR, Go runtime nije virtuelna mašina — ne interpretira bytecode, već se kompajlirani mašinski kod izvršava direktno, a runtime pruža podršku za goroutine scheduling, garbage collection i upravljanje memorijom.

#### Goroutine Scheduler

Go koristi **M:N threading model** — mnogo goroutina (G) se multipleksira na manji broj OS niti (M), koje se raspoređuju na logičke procesore (P). Scheduler je preemptivan od Go 1.14 što znači da se goroutine mogu prekinuti na bilo kojoj tački gdje postoji poziv funkcije, čime se sprečava da jedna goroutina monopolizuje procesorsko vrijeme.

Kada goroutina izvrši blokirajuću operaciju (npr. mrežni I/O, čekanje na mutex), scheduler je skida sa trenutne OS niti i stavlja u red čekanja, a na njeno mjesto raspoređuje drugu goroutinu. OS nit se nikada ne blokira za korisničke I/O operacije, što omogućava efikasno rukovanje hiljadama konkurentnih konekcija sa minimalnim brojem niti.

Work-stealing mehanizam balansira opterećenje: procesor koji nema goroutina u svom lokalnom redu preuzima goroutine iz reda drugog procesora.

Svaka goroutina zauzima inicijalno samo ~4 KB stack-a koji dinamički raste i smanjuje se po potrebi (growable / segmented stacks), za razliku od OS niti koje tipično alociraju 1-8 MB fiksnog stack-a.

#### Garbage Collector

Go koristi **concurrent, tri-color mark-and-sweep** garbage collector koji radi paralelno sa aplikacijom. Tri boje (bijela, siva, crna) označavaju stanje objekata u procesu označavanja:

- **Bijeli** objekti su kandidati za brisanje.
- **Sivi** su pronađeni ali njihove reference još nisu ispitane.
- **Crni** su potpuno obrađeni.

GC cilja na minimalne stop-the-world pauze (tipično ispod 1 ms), što je posebno važno za Ordering servis koji mora održavati niske latencije na HTTP odgovorima. GOGC environment varijabla kontroliše koliko često se GC pokreće — podrazumijevano je 100 (GC se pokreće kada se heap udvostruči od prethodnog ciklusa).

#### Channels i Select

Channels su Go-ov primarni mehanizam za komunikaciju između goroutina. Ponašaju se kao tipizirani, thread-safe redovi poruka. Mogu biti buffered (asinhrani — pošiljalac ne čeka dok se buffer ne napuni) ili unbuffered (sinhroni — pošiljalac čeka dok primalac ne preuzme poruku).

`select` naredba omogućava goroutini da čeka na više kanala istovremeno i reaguje na prvi koji postane dostupan. U Ordering sistemu ovo se koristi za multipleksiranje Kafka poruka, timeout-a i signala za graceful shutdown:

```
select {
case event := <-kafkaEvents:
    handleOrderEvent(event)
case <-ctx.Done():
    log.Info("shutting down consumer")
    return
}
```

### 3.3 `net/http` paket — HTTP Server

`net/http` je dio Go standardne biblioteke i pruža kompletnu implementaciju HTTP/1.1 i HTTP/2 servera i klijenta bez eksternih zavisnosti.

#### Server arhitektura

`http.Server` je centralna struktura koja vezuje TCP listener za handler. Za svaku pristiglu konekciju, server pokreće novu goroutinu koja čita zahtjeve, poziva registrovani `http.Handler`, i šalje odgovor. Ovo znači da Ordering servis može istovremeno obrađivati hiljade zahtjeva bez eksplicitnog upravljanja thread pool-om što je odgovornost Go runtime scheduler-a.

Ključne konfigurabilne vrijednosti su: `ReadTimeout`, `WriteTimeout`, `IdleTimeout` (zatvaranje neaktivnih keep-alive konekcija), i `MaxHeaderBytes`. Ovi parametri su bitni za zaštitu od slow-read / slow-write napada.

#### `http.Handler` interfejs

Sva obrada zahtjeva u Go-u se svodi na jedan interfejs:

```
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Svaka funkcija ili struktura koja implementira ovaj interfejs može obrađivati HTTP zahtjeve. Middleware-i su jednostavno Handler-i koji omotavaju (wrap) druge Handler-e: primaju zahtjev, vrše obradu (autentifikacija, logging, rate limiting), i prosljeđuju zahtjev sljedećem handler-u u lancu.

#### `http.Request` i `context.Context`

Svaki HTTP zahtjev nosi `context.Context` koji omogućava propagaciju deadlines, cancellation signala i request-scoped metadata (npr. `user_id` ekstrahovan iz JWT tokena) kroz cijeli lanac obrade. Kada klijent zatvori konekciju ili istekne timeout, Context se poništava i svi downstream pozivi (baza, Redis, Kafka) mogu biti prekinuti.

### 3.4 Chi Router

`chi` je lightweight HTTP router i middleware framework za Go koji se naslanja direktno na `net/http` interfejs (ne uvodi sopstvene apstrakcije). Koristi se u Ordering servisu jer pruža:

- **Radix tree routing** — efikasno uparivanje URL putanja, uključujući parametrizovane rute (`/orders/{orderID}`) i wildcard-e. Radix tree minimizuje broj poređenja pri rutiranju u odnosu na linearnu pretragu.
- **Middleware chaining** — chi organizuje middleware u stek koji se izvršava redom. Globalni middleware-i (logging, recovery, timeout) primjenjuju se na sve rute, dok se specifični (auth, RBAC provjera) primjenjuju na grupe ruta.
- **Route grouping** — grupisanje ruta po domenskoj odgovornosti sa zasebnim middleware stekovima. U Ordering servisu:
  - `/api/orders/*` — zahtijeva autentifikaciju kupca
  - `/webhooks/shipping` — zahtijeva HMAC verifikaciju (bez korisničke autentifikacije)
  - `/internal/health` — bez autentifikacije (health check za load balancer)
- **`chi.URLParam(r, "orderID")`** — ekstrakcija parametara iz URL-a putem request context-a, bez globalnog mutable state-a.

### 3.5 Middleware arhitektura

Middleware-i u Ordering servisu formiraju pipeline kroz koji svaki zahtjev prolazi prije nego što stigne do poslovne logike. Svaki middleware je Go funkcija koja prima `http.Handler` i vraća novi `http.Handler`:

```
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // validacija tokena...
        next.ServeHTTP(w, r)
    })
}
```

Redoslijed izvršavanja u Ordering servisu:

1. **Recovery** — hvata panic-e i pretvara ih u HTTP 500, sprečava pad cijelog procesa.
2. **Request ID** — generiše jedinstveni ID za svaki zahtjev radi traceability-ja kroz logove.
3. **Structured Logging** — loguje metapodatke zahtjeva (metod, putanja, trajanje, status kod) u JSON formatu.
4. **Timeout** — postavlja maksimalno trajanje obrade zahtjeva putem `context.WithTimeout`. Ako handler ne završi u roku, Context se poništava i klijentu se vraća HTTP 504.
5. **Rate Limiting** — provjerava Redis counter za IP/korisnika i odbija zahtjeve koji prekorače limit sa HTTP 429.
6. **Auth** — validira JWT token iz `Authorization` header-a, ubacuje `user_id` i `role` u request Context.

### 3.6 Business Logic — Order State Machine

Životni ciklus porudžbine je modelovan kao konačni automat (finite state machine) sa strogo definisanim dozvoljenim tranzicijama:

```
CREATED → PENDING_PAYMENT → PAID → SHIPPING → DELIVERED
                ↓                      ↓
            PAYMENT_FAILED         SHIP_FAILED
                ↓
            CANCELLED
```

Svaka tranzicija stanja se izvršava kroz sljedeći tok:

1. Provjera da li je tranzicija dozvoljena iz trenutnog stanja (lookup u mapi dozvoljenih tranzicija).
2. Primjena poslovnog pravila specifičnog za tu tranziciju (npr. pri prelasku u `PAID` mora postojati `payment_intent_id`).
3. Perzistencija novog stanja u Cassandra sa upisom u `order_status_history`.
4. Emitovanje Kafka eventa koji obavještava downstream servise o promjeni.

State machine odbija nedozvoljene tranzicije (npr. iz `DELIVERED` nazad u `SHIPPING`), čime se štiti integritet poslovnog toka.

### 3.7 Kafka Client (segmentio/kafka-go)

Apache Kafka se koristi kao message broker za asinhronu komunikaciju između Ordering, Payment i Shipping servisa. Go aplikacija koristi `segmentio/kafka-go` biblioteku koja pruža čist Go (pure-Go) Kafka klijent bez CGo zavisnosti.

#### Producer

Kafka producer šalje događaje na odgovarajuće topic-e. Ključne karakteristike:

- **Batching** — poruke se grupišu u batch-eve radi smanjenja broja mrežnih poziva. Batch se šalje kada dosegne konfigurisanu veličinu ili kada istekne flush interval.
- **Partitioning** — poruke se raspoređuju po particijama na osnovu ključa. Ordering servis koristi `order_id` kao partition key, čime se garantuje da svi eventi za istu porudžbinu stižu na istu particiju i obrađuju se u redosljedu.
- **Acknowledgment** — producer čeka potvrdu od Kafka broker-a da je poruka uspješno replicirana (`acks=all`), čime se garantuje da event neće biti izgubljen.

Topic-i koje producer koristi: `payment.requests`, `shipping.requests`, `notifications`, `order.events`.

#### Consumer

Kafka consumer čita događaje sa topic-a i obrađuje ih. Go aplikacija pokreće consumer u zasebnim goroutinama.

- **Consumer Group** — Ordering servis koristi consumer group tako da se svaka particija obrađuje od strane tačno jednog instance-a servisa, čime se omogućava horizontalno skaliranje.
- **Offset management** — offset (pozicija u particiji) se commit-uje tek nakon uspješne obrade poruke i perzistencije u Cassandru, čime se garantuje at-least-once semantika.
- **Idempotency** — pošto at-least-once može dovesti do duplih poruka, svaka poruka nosi `event_id` koji se provjerava u Redis deduplication cache-u prije obrade. Ako je `event_id` već viđen, poruka se preskače.

Topic-i koje consumer čita: `payment.results`, `shipping.status.updates`.

### 3.8 Redis integracija (go-redis)

Redis se koristi kao pomoćni in-memory sloj za četiri različite namjene u Ordering sistemu. Go aplikacija komunicira sa Redis-om putem `go-redis` biblioteke koja podržava connection pooling, pipelining i cluster mode.

#### Checkout Cache

Tokom checkout procesa, privremeno se čuvaju podaci o korpi (artikli, cijene, snapshot reference) u Redis hash strukturi sa TTL-om od 15 minuta. Ovo izbjegava ponovljene pozive ka Catalog servisu dok kupac popunjava adresu i bira način plaćanja. Ključ je oblika `checkout:{session_id}`.

#### Distributed Locking

Kada state machine obrađuje tranziciju stanja za jednu porudžbinu, mora se spriječiti da drugi zahtjev (ili Kafka consumer) istovremeno mijenja stanje iste porudžbine. Redis se koristi za distributed lock sa `SET order_lock:{order_id} {request_id} NX EX 10` — lock traje maksimalno 10 sekundi i automatski ističe ako holder ne završi obradu.

#### Deduplication Cache

Za Kafka poruke i webhook pozive, `event_id` se upisuje u Redis sa `SET dedup:{event_id} 1 NX EX 3600`. Ako SET vrati `nil` (ključ već postoji), poruka je duplikat i preskače se. TTL od 1 sat pokriva period unutar kojeg Kafka može izvršiti retry.

#### Rate Limiting

Implementiran sliding window rate limiter korišćenjem Redis sorted set-a. Za svaki zahtjev, timestamp se dodaje u sorted set sa ključem `ratelimit:{client_id}`. Stari zapisi (izvan vremenskog prozora) se brišu sa `ZREMRANGEBYSCORE`, a trenutni broj zahtjeva u prozoru se dobija sa `ZCARD`. Ako broj prekorači konfigurisani limit, zahtjev se odbija sa HTTP 429.

### 3.9 Webhook Endpoint — Shipping Callbacks

Ordering servis izlaže HTTP endpoint `/webhooks/shipping` koji je namijenjen isključivo za prijem statusnih ažuriranja od Shipping & Logistics servisa. Ovaj endpoint nije dostupan krajnjim korisnicima.

Webhook tok obrade:

1. **Prijem HTTP POST zahtjeva** — payload sadrži `shipment_id`, `order_id`, `status`, `timestamp` i `metadata` (npr. `tracking_url`, `carrier_message`).
2. **HMAC verifikacija** — tijelo zahtjeva se hashira sa HMAC-SHA256 koristeći dijeljeni tajni ključ. Hash se poredi sa vrijednošću iz `X-Webhook-Signature` header-a. Ako se ne poklapaju, zahtjev se odbija sa HTTP 401.
3. **Timestamp provjera** — `timestamp` iz payload-a se poredi sa trenutnim vremenom. Ako je razlika veća od 5 minuta, zahtjev se odbija (zaštita od replay napada).
4. **Idempotency provjera** — `event_id` se provjerava u Redis deduplication cache-u.
5. **State Machine tranzicija** — status pošiljke se mapira na odgovarajuću tranziciju stanja porudžbine (npr. `ShipmentDelivered` → `DELIVERED`).
6. **Perzistencija** — novo stanje se upisuje u Cassandru i emituje se Kafka event.
7. **HTTP 200 odgovor** — potvrda Shipping servisu da je webhook uspješno obrađen.

---

## 4. Dekompozicija Apache Cassandre

Apache Cassandra je distribuirana NoSQL baza podataka projektovana za visoku dostupnost i horizontalnu skalabilnost bez "single point of failure". U Ordering sistemu služi kao primarno skladište za porudžbine, stavke, status historiju i podatke o pošiljkama. U nastavku je detaljno razlaganje Cassandre na sastavne komponente.

### 4.1 Arhitektura klastera — peer-to-peer topologija

Cassandra koristi **peer-to-peer** arhitekturu u kojoj su svi čvorovi ravnopravni: nema master/slave razlika. Svaki čvor može primiti zahtjev za bilo koji podatak. Čvor koji primi zahtjev od klijenta postaje **coordinator** za taj zahtjev i odgovoran je za prosljeđivanje upita relevantnim čvorovima koji drže tražene podatke.

Klaster se organizuje u **data centre** i **rack-ove** koji modeliraju fizičku (ili cloud) topologiju. Ovo omogućava rack-aware i DC-aware replikaciju koja garantuje preživljavanje kvarova na nivou rack-a ili čitavog data centra.

### 4.2 Particioniranje podataka — Consistent Hashing

Cassandra raspodjeljuje podatke na čvorove korišćenjem **consistent hashing** algoritma. Svaki red u tabeli ima **partition key** (definisan u CQL šemi). Cassandra primjenjuje hash funkciju (Murmur3) na partition key i dobija token. On je 64-bitni integer. Svaki čvor u klasteru je odgovoran za opseg tokena (token range).

**Virtual nodes (vnodes)** omogućavaju da svaki fizički čvor bude odgovoran za više manjih opsega tokena umjesto jednog velikog. Ovo poboljšava ravnomjernu distribuciju podataka i ubrzava rebalansiranje kada se čvor doda ili ukloni iz klastera.

U kontekstu Ordering sistema:
- Tabela `orders` koristi `order_id` (UUID) kao partition key — garantuje ravnomjernu distribuciju jer je UUID pseudo-random.
- Tabela `order_status_history` koristi `order_id` kao partition key i `changed_at` (timestamp) kao clustering key — svi statusi jedne porudžbine su na istoj particiji, sortirani hronološki.

### 4.3 Replikacija

Svaka particija se replicira na više čvorova prema konfigurisanom **replication factor-u** (RF). Za Ordering sistem koristi se RF=3, što znači da su podaci o svakoj porudžbini čuvani na tri čvora.

**NetworkTopologyStrategy** omogućava definisanje broja replika po data centru. Cassandra bira replike uzimajući u obzir rack topologiju, garantujući da se replike ne nalaze u istom rack-u kada je to moguće.

Replikacija je asinhrona — coordinator šalje write zahtjev svim replikama, ali čeka potvrdu od broja replika definisanog consistency level-om.

### 4.4 Write Path — put podataka od klijenta do diska

Kada Go aplikacija izvrši CQL INSERT (npr. nova porudžbina), podaci prolaze kroz sljedeće komponente:

1. **Coordinator čvor** prima zahtjev i na osnovu partition key-a određuje koje čvorove (replike) treba kontaktirati.
2. **Commit Log** — na svakoj replici, podaci se prvo upisuju sekvencijalno u append-only commit log na disku. Ovo je write-ahead log koji garantuje durability. Čak i ako čvor padne odmah nakon upisa, podaci se mogu rekonstruisati iz commit log-a pri ponovnom pokretanju.
3. **Memtable** — nakon upisa u commit log, podaci se upisuju u memtable, in-memory strukturu sortiranu po partition key i clustering key. Memtable pruža brzo čitanje nedavno upisanih podataka.
4. **Flush to SSTable** — kada memtable dostigne konfigurisanu veličinu ili broj commit log segmenata, cjelokupna memtable se serijalizuje i upisuje na disk kao **SSTable** (Sorted String Table). SSTable je immutable — jednom zapisan, nikada se ne mijenja.

### 4.5 Read Path — put podataka od diska do klijenta

Kada Go aplikacija izvrši CQL SELECT (npr. dohvatanje porudžbine po `order_id`):

1. **Coordinator** prima zahtjev i prosljeđuje ga replikama.
2. **Bloom Filter** — probabilistička struktura podataka koja brzo provjerava da li SSTable *možda* sadrži traženi partition key. Ako Bloom filter kaže "ne", SSTable se preskače bez čitanja sa diska. False positive je moguć, false negative nije.
3. **Partition Index** — ako Bloom filter kaže "možda da", pretražuje se partition index koji mapira partition key na offset u SSTable fajlu.
4. **Compression Offset Map** — locira kompresovani blok unutar SSTable-a.
5. **SSTable čitanje** — podaci se čitaju sa diska.
6. **Memtable provjera** — istovremeno se provjerava memtable jer može sadržati novije podatke koji još nisu flush-ovani.
7. **Merge** — rezultati iz svih SSTable-ova i memtable-a se spajaju. Za isti ključ, noviji timestamp uvijek pobjeđuje (last-write-wins).

### 4.6 Compaction

Pošto su SSTables immutable i operacije UPDATE i DELETE ne mijenjaju postojeće fajlove (UPDATE kreira novi zapis sa novijim timestamp-om, DELETE kreira **tombstone** marker), broj SSTable fajlova raste tokom vremena. Compaction je pozadinski proces koji spaja više SSTable-ova u jedan, pri čemu:

- uklanja tombstone-ove starije od `gc_grace_seconds` (podrazumijevano 10 dana)
- zadržava samo najnoviju verziju svakog reda
- smanjuje fragmentaciju i poboljšava read performanse

Cassandra podržava različite compaction strategije:

- **SizeTieredCompactionStrategy (STCS)** — spaja SSTable-ove slične veličine. Dobro za write-heavy workload-e. Ordering servis koristi ovu strategiju za tabelu `order_status_history` jer su upisi frekventniji od čitanja.
- **LeveledCompactionStrategy (LCS)** — organizuje SSTable-ove u nivoe sa garantovanim ograničenjima veličine. Pruža konzistentnije read performanse. Koristi se za tabelu `orders` jer se porudžbine često čitaju (praćenje statusa od strane kupca).
- **TimeWindowCompactionStrategy (TWCS)** — grupiše SSTable-ove po vremenskim prozorima. Idealno za time-series podatke jer omogućava efikasno brisanje starih podataka.

### 4.7 Gossip protokol i Failure Detection

Čvorovi u klasteru komuniciraju međusobno putem **Gossip protokola** — peer-to-peer protokola u kojem svaki čvor periodično (svake sekunde) razmjenjuje informacije o stanju klastera sa 1-3 nasumično izabrana čvora. Informacije koje se razmjenjuju uključuju:

- koji čvorovi su aktivni, a koji nedostupni
- schema verziju svakog čvora
- opterećenje (količinu podataka) svakog čvora
- token opsege

**Phi Accrual Failure Detector** je mehanizam koji Cassandra koristi za određivanje da li je čvor nedostupan. Umjesto binarnog "živ/mrtav" stanja, Phi detector računa vjerovatnoću da je čvor pao na osnovu historije heartbeat intervala. Ako phi vrijednost prekorači konfigurisani prag, čvor se proglašava nedostupnim i coordinator preusmjerava zahtjeve na druge replike.

### 4.8 CQL (Cassandra Query Language)

CQL je SQL-like jezik za interakciju sa Cassandra bazom. Iako sintaksa podsjeća na SQL, semantika je fundamentalno drugačija:

- **Nema JOIN-ova** — podaci se modeliraju denormalizovano prema obrascima upita (query-driven modeling). U Ordering sistemu, stavke porudžbine su dio iste particije kao i order header, što eliminše potrebu za join-om.
- **Partition key je obavezan u WHERE klauzuli** — Cassandra ne podržava full-table scan-ove u produkciji. Svaki upit mora specificirati partition key, čime se čitanje svodi na jednu particiju na jednom čvoru (ili malom broju čvorova ako je RF > 1).
- **Clustering key definiše sortiranje unutar particije** — na primjer, `order_status_history` tabela koristi `changed_at DESC` kao clustering order, pa se najnoviji status uvijek vraća prvi.
- **Prepared statements** — CQL podržava pripremljene upite koji se parsiraju i optimizuju jednom, a zatim izvršavaju višestruko sa različitim parametrima. Go aplikacija koristi prepared statements za sve upite, čime se izbjegava overhead ponovnog parsiranja i štiti od CQL injection napada.

Primjer šeme za Ordering sistem:

```
CREATE TABLE orders (
    order_id    UUID,
    customer_id UUID,
    status      TEXT,
    total       DECIMAL,
    currency    TEXT,
    shipping_address TEXT,
    created_at  TIMESTAMP,
    updated_at  TIMESTAMP,
    PRIMARY KEY (order_id)
);

CREATE TABLE order_status_history (
    order_id   UUID,
    changed_at TIMESTAMP,
    status     TEXT,
    reason     TEXT,
    actor      TEXT,
    PRIMARY KEY (order_id, changed_at)
) WITH CLUSTERING ORDER BY (changed_at DESC);

CREATE TABLE shipments (
    shipment_id     UUID,
    order_id        UUID,
    tracking_number TEXT,
    carrier         TEXT,
    status          TEXT,
    created_at      TIMESTAMP,
    updated_at      TIMESTAMP,
    PRIMARY KEY (order_id, shipment_id)
);
```

### 4.9 Consistency Levels

Cassandra omogućava podešavanje nivoa konzistentnosti po upitu, čime se kontroliše trade-off između konzistentnosti i performansi/dostupnosti:

| Nivo | Značenje | Korišćenje u Ordering sistemu |
|---|---|---|
| `ONE` | Čeka potvrdu od jedne replike | Read-ovi za prikaz historije statusa (tolerišemo kratko kašnjenje) |
| `QUORUM` | Čeka potvrdu od većine replika (2 od 3 za RF=3) | Write-ovi za promjenu stanja porudžbine (garantuje konzistentnost) |
| `LOCAL_QUORUM` | QUORUM unutar lokalnog data centra | Smanjuje latenciju u multi-DC deploymentu |
| `ALL` | Čeka potvrdu od svih replika | Ne koristi se — žrtvuje dostupnost |

Za Ordering sistem, kritični write-ovi (kreiranje porudžbine, promjena stanja) koriste `QUORUM`, dok read-ovi za prikaz podataka kupcu koriste `ONE` jer kratko kašnjenje u vidljivosti nove promjene stanja je prihvatljivo.

Kombinacija `QUORUM` write + `QUORUM` read garantuje **strong consistency** (R + W > RF → čitač uvijek vidi najnoviji zapis), što je neophodno za integritet životnog ciklusa porudžbine.

### 4.10 Lightweight Transactions (LWT)

Za operacije koje zahtijevaju compare-and-set semantiku, Cassandra nudi Lightweight Transactions zasnovane na Paxos konsenzus protokolu:

```
UPDATE orders SET status = 'PAID'
WHERE order_id = ?
IF status = 'PENDING_PAYMENT';
```

LWT garantuje linearizabilnost za pojedinačnu particiju: ažuriranje će se izvršiti samo ako je trenutni status zaista `PENDING_PAYMENT`. Ovo je dodatni sloj zaštite za state machine u situacijama gdje distributed lock u Redis-u nije dovoljan (npr. pri oporavku od mrežne particije).

LWT su značajno sporije od regularnih write-ova (zahtijevaju više round-trip-ova između replika za Paxos protokol), pa se koriste samo za kritične tranzicije stanja.

### 4.11 JMX Interface

Java Management Extensions (JMX) interfejs pruža pristup internim metrikama i administrativnim operacijama Cassandra čvora. Putem JMX-a se može:

- pratiti stanje compaction-a (broj pending compaction taskova, brzina obrade)
- pratiti veličinu memtable-ova i bloom filtera
- pokrenuti manualni repair, flush ili compaction
- pratiti latencije čitanja i pisanja po tabeli
- pregledati stanje gossip protokola i topologiju klastera

`nodetool` je command-line alat koji komunicira sa Cassandrom preko JMX interfejsa i koristi se za operativnu administraciju (npr. `nodetool status`, `nodetool repair`, `nodetool compactionstats`).

### 4.12 Snitch

Snitch je komponenta koja određuje topologiju klastera — koji čvor pripada kom data centru i rack-u. Na osnovu toga Cassandra donosi odluke o replikaciji (raspoređuje replike u različite rack-ove) i routing-u (coordinator bira najbliže replike za čitanje).

- **SimpleSnitch** — za single-DC deployment, ne razlikuje rack-ove.
- **GossipingPropertyFileSnitch** — svaki čvor deklariše svoj DC i rack u konfiguracionom fajlu, a informacija se propagira putem gossip protokola. Ovo je preporučena konfiguracija za produkcijske klastere.
- **Ec2Snitch / GoogleCloudSnitch** — automatski detektuje DC i rack na osnovu cloud provajdera.

---

## 5. Shipping & Logistics sistem — komunikacioni model

Shipping & Logistics sistem je eksterni servis koji komunicira sa Ordering sistemom putem dva kanala:

### 5.1 Kafka kanal (Ordering → Shipping)

Ordering servis šalje `ShippingInitiated` event na Kafka topic `shipping.requests` nakon potvrđenog plaćanja. Event sadrži:

```
{
    "event_id": "evt_a1b2c3",
    "order_id": "ord_x7y8z9",
    "shipping_address": {
        "street": "...",
        "city": "...",
        "postal_code": "...",
        "country": "..."
    },
    "items": [
        {"product_id": "p1", "name": "...", "quantity": 2, "weight_g": 500}
    ],
    "created_at": "2025-01-15T10:30:00Z"
}
```

Shipping servis konzumira ovaj event, kreira pošiljku kod logističkog provajdera, i od tog trenutka komunikacija se odvija putem webhook-a.

### 5.2 Webhook kanal (Shipping → Ordering)

Shipping servis šalje statusna ažuriranja putem HTTP POST webhook poziva na Ordering endpoint `/webhooks/shipping`. Payload primjer:

```
{
    "event_id": "shp_evt_001",
    "shipment_id": "shp_abc123",
    "order_id": "ord_x7y8z9",
    "status": "ShipmentDispatched",
    "timestamp": "2025-01-16T08:00:00Z",
    "metadata": {
        "tracking_number": "1Z999AA10123456784",
        "carrier": "UPS",
        "estimated_delivery": "2025-01-20"
    }
}
```

Header `X-Webhook-Signature` sadrži HMAC-SHA256 potpis tijela zahtjeva, koji Ordering servis verifikuje prije obrade.

### 5.3 Životni ciklus pošiljke

```
ShipmentCreated → ShipmentDispatched → ShipmentInTransit → ShipmentDelivered
                                                ↓
                                          ShipmentFailed
```

Svaki statusni prelaz u Shipping sistemu mapira se na odgovarajuću tranziciju stanja porudžbine u Ordering sistemu:

| Shipping status | Order state tranzicija | Akcija u Ordering sistemu |
|---|---|---|
| `ShipmentCreated` | `PAID` → `SHIPPING` | Čuva `shipment_id` i `tracking_number` u D4 |
| `ShipmentDispatched` | (ostaje `SHIPPING`) | Ažurira `tracking_info` u D4, notifikuje kupca |
| `ShipmentDelivered` | `SHIPPING` → `DELIVERED` | Zatvara porudžbinu, emituje `OrderCompleted` event |
| `ShipmentFailed` | `SHIPPING` → `SHIP_FAILED` | Pokreće proces ponovnog slanja ili refund-a |
